# 1. Системы контроля версий
## 1.1 Системы управления версиями

Checkout - извлечение версии

Состояния фала в Git:
* Зафиксированный (committed) - файл уже сохранен в локальной базе
* Измененный (modified) - файлы, которые изменились, но еще не зафиксированы
* Подготовленный (staged) измененные файлы, отмеченные для включения в следующий коммит.
## 1.2 Начало работы с Git
`git config --system ` - системная конфигурация (/etc/gitconfig)

`git config --global` - конфигурация пользователя (~/.gitconfig/ или ~/.config/git/config)

`git config --local` - конфигурация в репозитории (./git/config)

`git config --list --show-origin` - посмотреть все настройки и где они заданы.

`git config --global user.name “Eugeni.Sai”` - установить имя пользователя

`git config --global user.email literis8@gmail.com` - установить электронную почту

`git init` - создать пустой репозиторий в текущей директории

`git add <file>` - взять файл под контроль версий. (staged)

`git commit -m “message”` - выполнить коммит добавив сообщение “message” 

`git clone <url> <dir>` - клонировать репозиторий по url в директорию dir

`git status` - показать какие файлы в каком состоянии находятся.

`git status -s` - (--short) упрощенный вывод статуса

`./.gitignore` - список файлов которые не должны попасть в репозиторий.

https://github.com/github/gitignore - набор различных шаблонов gitignore

`git diff --staged` - отобразить изменения файлов staged

`git push` - отправка изменений в репозиторий

https://guides.github.com/features/mastering-markdown/ - краткое описание языка markdown
# 2. Основы Git
## 2.1 Работа с историей изменений файлов Git
`git diff` - отобразить не проиндексированные изменения файлов modified

`git diff --staged` `git diff --cached`- отобразить проиндексированные изменения файлов staged с последним коммитом

`git difftool` - графическая утилита для сравнения изменений

`git commit -v` - добавить в комментарий коммита diff

`git config --global core.editor <editor>` - изменить редактор текста коммита

`git commit -a` - взять под контроль версий все модифицированные файлы и сделать коммит

`git rm <file>`- удалить файл и добавить изменение в коммит

`git rm -f <file>` - удалить файл если он уже проиндексирован

`git rm --cached <file>` - оставить файл на диске, но перестать отслеживать

`git rm -n|--dry-run <file> `- посмотреть результат выполнения без удаления

`git mv <file1> <file2>` - переименовать/переместить file1 в file2

`git log` - показать историю коммитов

`git log -[n]`- отобразить последние n коммитов

`git log -p (--patch)` - показать изменения в каждом коммите

`git log --stat` - показать общую разницу для каждого коммита

`git log --pretty=oneline|short|full|fuller` - изменить способы вывода

`git log --pretty=format:”%h - %an, %ar : %s”` - свой формат вывода

`git log --shortstat` - отображает только строку с количеством изменений/вставок/удалений для команды `--stat`

`git log --name-only` - показывает список измененных файлов после информации о коммите

`git log --name-status` - показывает список файлов которые добавлены/изменены/удалены

`git log --abbrev-commit` - показывает только несколько символов SHA-1 чек суммы вместо всех 40

`git log --relative-date` - отображает дату в относительном формате

`git log --graph` - отображает граф с ветвлениями

`git log --oneline` - сокращение для одновременного использования опций `--pretty=oneline --abbrev-commit`

`git log --since <2008-01-15>` - показывает все коммиты с указанной даты

`git log --after <2 years 1 day 3 minutes ago>` - показывает все коммиты по относительной дате

`git log --until <2008-01-15>` - показывает все коммиты до указанной даты

`git log --before <2 years 1 day 3 minutes ago>` - показывает все коммиты до относительной даты

`git log --autor <name>` - показать коммиты с автором name

`git log --commiter <name>` - показать коммиты с коммитером name

`git log --grep <string>` - показать коммиты в сообщении которых есть строка string

`git log -S <string>` - показать коммиты в которых изменение в коде повлекло за собой добавление или удаление строки string

`git log --no-merges` - не отображает коммиты мерджа
## 2.2 Операции отмены
`git commit --amend` - добавить изменения в предыдущий коммит

`git reflog` - показать коммиты в т.ч. скрытые за счет amend, показывает журнал текущего окружения, фиксирует все изменения в локальном репозитории, в т.ч. историю перемещения заголовков

`git restore --staged <file>` или `git reset HEAD <file>` - убрать файл из статуса staged (подготовленного к коммиту)

`git reset --hard` - сбрасывает любые изменения до последнего коммита

`git restore <file>` илм `git checkout -- <file>` - удалить все изменения в файле со статусом modified
## 2.3 Удаленный репозиторий
`git remote` - вывод списка удаленных репозиториев

`git remote -v` - более подробный вывод

**origin** - имя по умолчанию, даваемое серверу, с которого производилось клонирование репозитория.

`git fetch [remorte name]` - получить данные из удаленного репозитория _remote name_ (по умолчанию _origin_)

`git push [remote-name] [branch-name]`- отправить данные в удаленный репозиторий _remote-name_ из ветки _branch-name_ (по умолчанию из текущей ветки в репозиторий _origin_)

__fork__ - ответвления от основного репозитория

`git remote add <name> <source>` - добавить удаленный репозиторий с именем _name_ и источником _source_

`git pull` - извлекает (fetch) данные с сервера, и пытается автоматически слить (merge) их с кодом над которым в данный момент работаете

`git remote show <remote-name>` - просмотр удаленного репозитория _remote-name_

`git remote rename <oldname> <newname>` - переименовать удаленный репозиторий

`git remote rm <name>` - удалить удаленный репозиторий

`git fetch --all` - получить данные из всех удаленных репозиториев
## 2.4 Теги
Чаще всего теги используют для обозначения версий.

`git tag` - показать все теги

`git tag -l <text>` - показать теги с шаблоном _text_

**легковесный тег** - содержит только название тега и коммита к которому привязан

**аннотированный тег** - полноценный объект содержащий информацию об авторе, дате создания и комментарий.

`git tag -a <tag-name> -m ‘message’` - создать аннотированный тег с именем _tag-name_ и описанием _message_

`git show <tag>` - отобразить все коммиты с тегом _tag_

`git tag <tagname>` - создать легковесный тег

`git tag -a <tagname> [commit-sha1]` - создать аннотированный тег к коммиту с хешем _commit-sha1_

Теги не отправляются при обычном выполнении push, для отправки тегов используются отдельные команды

`git push <remote> <tag-name>` - отправить в репозиторий remote тэг _tag-name_

`git push <remote> --tags` - отправить все теги в репозиторий _remote_

`git tag -d <tag-name>` - удалить тэг _tag-name_

`git push <remote> :/refs/tags/<tag-name>` или `git push <remote> --delete <tag-name>` - удалить из удаленного репозитория remote тэг _tag-name_

`git checkout <tag>` - переключится на коммит с тегом _tag_

`git checkout -b <branc-hname> <tag>` или `git switch -c <branch-name> <tag>` - создать новую ветку с именем _branch-name_ от тега _tag_

`git config --global alias.<alias> <command>` - создать алиас для команды например `git config --global alias.co checkout` позволит вместо `git checkout` писать `git co`
## 2.5 Киллер фича - ветвления
При переключении ветки изменяются файлы в текущем каталоге, если git не может применить состояние, он не позволит переключиться.

`git log --all` - вывести информацию о всех ветках

`git checkout -b <new-branch>` или `git switch -c <new-branch>` - создать новую ветку с именем _new-branch_ и переключится на нее
# 3. Ветвления в Git
## 3.1 Слияния (merge)
`git checkout <branch>` - переключиться на ветку.

`git branch <branch>` - создать ветку не переключаясь в нее

`git merge <branch>` - произвести слияние ветки _branch_ в текущую ветку

**fastforward merge** - слияние при котором указатель ветки основной ветки перемещается на указатель ответвления (в случае если основная ветка не имела дополнительных коммитов после ответвления)

`git branch -d <branch>` - удалить ветку _branch_

**recursive merge** - слияние при котором основная ветка имела коммиты после ответвления.

**merge commit** - коммит образованный после рекурсивного слияния

Для разрешения конфликта достаточно зайти в файл в котором был обнаружен конфликт, в нем будет помечено какие строчки конфликтуют. После разрешения конфликта нужно повторно взять файл под контроль версий командой git add, и завершить коммит.

`git push <repo> <branch-local>:<branch-remote>` - преобразовать имя локального репозитория _branch-local_ в имя удаленного репозитория _branch-remote_.
## 3.2 Преобразование (Rebase)
`git rebase <branch>` - поменять родителя на _branch_ (аналогично мердж, но без создания мердж коммита), после, мердж произойдет через fastforward

`git rebase --onto <branch1> <branch2> <branch3>` - Переключись на ветку _branch3_, найди изменения относительно ветки _branch2_, и примени к ветке _branch1_. После мердж произойдет через fastforward. При указанной схеме ветвления:

`git rebase <branch1> <branch2>` - поменять родителя _branch2_ на _branch1_ не переключаясь
## 3.3 Пользовательские скрипты (Хуки)
**Хуки** – серверные скрипты запускающиеся при определенных событиях. Хранятся в .git/hooks/.

**Клиентские хуки** выполняются на локальной машине. Нет гарантии их выполнения, не копируются при клонировании репозитория.
* **pre-commit** – выполняется перед коммитом, используются для простых юнит тестов, проверки стиля кода и др. игнорируется флагом --no verify (git commit --no-verify)
* **prepare-commit-msg** - выполняется до вызова редактора сообщения, но после создания стандартного сообщения, позволяет изменять стандартные сообщения коммитов.
* **commit-msg** - принимает на вход путь к временному файлу с сообщением к коммиту, позволяет проверить сообщение коммита на основании шаблонов.
* **post-commit** - не принимает никаких параметров, данные последнего коммита можно получить git log -1 HEAD, не влияет на работу Git.
* **pre-rebase** - применяется при rebase, запрещает rebase при ненулевом выводе
* **pre-rewrite** - запускается командами `git commit --amend`, `git rebase` (но не `git filter-branch`), может запретить rebase.
* **post-checkout** - выполняется после успешного выполнения `git checkout`, может использоваться для настройки рабочей директории под конкретную ветку.
* **post-merge** - после успешного выполнения `git merge`, можно восстановить какие-либо данные в рабочей директории не отслеживаемые гитом.
* **pre-push** - во время выполнения `git push`: после обновления удаленных ссылок, но до непосредственной отправки данных. Может отменить отправку данных.

**Серверные хуки** выполняются при взаимодействии с удаленным репозиторием.
* **pre-receive** - при старте получения данных от клиента, может отменить получение всех изменений, может использоваться для быстрой проверки кода или сообщения коммита.
* **update** - похож на **pre-receive**, но вызывается для каждой ветки отдельно, может отменять изменения для конкретной ветки, можно использовать для проверки права разработчиков пушить в конкретную ветку.
* **post-receive** - после принятия всех данных, может быть использован для уведомления внешних сервисов. Не может прервать процесс, но клиент останется подключенным до завершения работы этого хука.

## Дополнительно
[Тренажер для работы с гит](https://learngitbranching.js.org/)
# 4. Инструменты Git
## 4.1 Выбираем коммиты, прячем изменения, очищаем каталоги
`git show <sha1>|<branch-name>|<tag>` - отобразить состояние и изменение коммита по хэш или по указателю ветки или по тегу

`git rev-parse <branch-name>` - отобразить хэш коммита на который указывает указатель ветки

`git show HEAD@{n}` - позволяет показать коммит n в истории перемещения заголовков по выводу команды `git reflog`

`git show <branch>@{yesterday}` - показать последний вчерашний коммит из ветки _branch_

`git show HEAD@{2.month.ago}` - показать последний коммит на котором был указатель 2 месяца назад

`git log -g <branch>` - показать историю перемещения ветки _branch_ от коммита к коммиту

`git show HEAD|[sha1]|[branch]^` - показать родителя текущего выбранного коммита, родителя комита с хешем _sha1_ или родителя ветки _branch_ (**показывает только одного родителя**)

`^n` - показать n предков

`~n` - посмотреть пред родителя в n поколении

`git log <branch1>..<branch2>` - показать коммиты ветки _branch2_ исключив общие коммиты с веткой _branch1_ пример: `git log origin/main..HEAD` покажет изменения текущей ветки по отношению к _origin/main_

`^` или `--not` - позволяет исключить указанные коммиты ветки, можно использовать больше 2-х веток пример: `git log ^origin/main HEAD`, `git log HEAD --not origin/main`

`git log <branch1>...<branch2>` - отобразить коммиты которые есть в _branch1_, в _branch2_ исключив те что есть в обеих ветках сразу, опция `--left-right` укажет к какой ветке относится какой коммит

`git add -i` - интерактивное индексирование индексирует файлы по одному, полезно когда изменения надо вносить не одним большим пакетом, а разделить на несколько маленьких

`git stash` - спрятать проиндексированные файлы (что-то вроде кеша)

`git stash list` - отобразить список произведенных stash

`git stash apply [stash@{n}]` - восстановить последний или указанный stash флаг `--index` восстановит проиндексированный статус файлов

`git stash drop [stash@{n}]` - удалить все или указанный stash

`git stash --keep-index` - не прятать то что добавлено в индекс

`git stash --include-untracked` - так же спрятать untracked файлы

`git stash --patch` - интерактивный режим

`git stash branch <branch-name>` - создать ветку из спрятанных изменений

`git clean` - очистка рабочей директории. Параметры:
* `-n, --dry-run` - ничего не удалять, только показать что будет удалено
* `-f, --force` - удалить
* `-d` - удалять директории
* `-q, --quit` - тихий режим
* `-x` - удалить в т.ч. .gitignore
* `-i, --interactive` - интерактивный режим
## 4.2 Поиск в Git
`git grep <string>` - утилита поиска строки _string_, списки параметров:
* `-n, --line-number` - отобразить номера строк
* `-c, --count` - показать количество совпадений в файлах\
* `-p, --show-function` - показать метод или функцию в которой присутствует совпадение
* `--and, --or, --not` - логические операторы
* `--break` - добавить пустые строки между результатами
* `--heading` - отобразить имена файлов группой найденных строк

`git log -S<string> --onleine` - в каком коммите была добавлена или удалена _string_

`git log -L :<function>:<file>` - найти внутри файла _file_ изменения в функции _function_

**Бинарный поиск** - задаются 2 коммита, отмечается плохой и рабочий коммит, после чего поиск делит разницу пополам и выдает коммит посередине

`git bisect start [bad_commit] [good_commit]` - запуск поиска

`git bisect bad [branch]|[sha1]|[tag]` - задать плохой коммит (по умолчанию текущий)

`git bisect good [branch]|[sha1]|[tag]` - задать рабочий коммит

`git bisect reset` - выйти из режима бинарного поиска

`git bisect run <script.sh>` - запуск скрипта теста, если скрипт вернул 0 - коммит хороший, иначе плохой
