# Основы системного администрирования.
## 1. Работа в терминале (лекция 1).
__FHC__ (filesystem hierarchy standard) - иерархический стандарт директорий Linux

`whoami` - отобразить имя пользователя

`pwd` - отобразить текущую директорию

`alias` - вывести список алиасов

`alias new_alias="comand"` - задать алиас

`~/.bashrc` - файл в который можно задать постоянные алиасы

`which <command>` - вывести расположение исполняемого файла команды

`type <command>` - отобразить исполняемый файл команды

`read [var]` - прочитать введенные данные в переменную _var_

`echo $var` - вывести значение переменной

### Vagrant
**Vagrant** - система оркестрации виртуальных машин (в нашем случае для оркестрации oracle Virtual BOX)

`vagrant init` - инициализация виртуальной машины в выбранной директории

`vagrant up` - запустить виртуальную машину

`vagrant suspend` - приостановить виртуальную машину

`vagrant halt` - выключить виртуальную машину

`vagrant ssh` - подключиться по ssh к виртуальной машине
## 2. Работа в терминале (лекция 2)

**Потоки данных:**
* **stdin** - стандартный ввод, условный номер (дескриптор) 0 (например ввод команды в shell)
* **stdout** - стандартный вывод, условный номер (дескриптор) 1 (например вывод результата команды на экран)
* **stderr** - стандартный вывод ошибок, условный номер (дескриптор) 2 (например вывод ошибки на экран при неправильных 
аргументах команды)

**Процесс** - экземпляр запущенной программы

`lsof` - список открытых файлов (в колонке FD отмечены дескрипторы файлов)

**_Открытие любых файлов приводит к выделению им файловых дескрипторов, все они получают номера_**

`/dev` - псевдо-файловая система представления устройств

`/proc` - псевдо-файловая система представления структур ядра (информация в директории актуальна только на момент
просмотра и постоянно изменяется)

**_С псевдо-файловыми системами доступна работа только в режиме Read-only_**

`evtest /dev/input/event2` - тестирования потока ввода с устройства

**PID, Process Identifier** - числовой идентификатор процесса, однозначно его определяющий. Находясь в shell, 
мы можем узнать собственный PID через зарезервированную переменную `$`: `echo $$`.

`jobs -l` - вывести фоновые задачи (отправленные в фон через ctrl+z), параметр `-l` указывает pid

**_PPID, Parent PID - атрибут процесса, определяющий идентификатор его родительского процесса. 
Все процессы в Linux выстроены в дерево и должны иметь “родителя”. Так, для sleep 1h родителем будет bash, 
из которого sleep вызвали. Для PPID в shell так же есть одноименная переменная: `echo $PPID`_**

`pstree -p [pid]` - отобразить дерево процессов, `-p` отображает PID

Часть информации в `/proc` представлена с группировкой по PID: в `/proc/<PID>` 
находятся относящиеся к конкретному процессу данные.

`lsof -p [pid]` - вывести список открытых файлов связанных с _pid_

`[1,2]>` (по умолчанию `1>`) - перенаправить поток (при перенаправлении в поток добавить `&` например `2>&1`)

`<` - перенаправить поток ввода (например: `read NEW_WAR < text`)

`|` - pipe, перенаправить stdout одного в stdin другого 

`||` - логическое или

`&&` - выполнить команду после успешного завершения предыдущей

`;` - выполнить команду после предыдущей

`<comand> $(<function> [arg])` - передать команде на выполнение результат функции
## 3. Операционные системы (лекция 1)
**POSIX** - (Portable  Operating System Interface for UniX) Совместимая UNIX-подобная ОС Linux

**Системные вызовы** – метод общения приложений и ОС. Напрямую системные вызовы используются редко,
а формат обращения к ним сложен для прикладного программирования. Над системными вызовами написаны библиотеки,
которые удобнее для прямого вызова программистами.

`ldd` — скрипт в UNIX/Linux, помогающий определить список разделяемых библиотек (shared libraries),
от которых зависит программа.

`strace <command>` – программа, использующая подсистему ядра ptrace для отслеживания системных вызовов.
Основной недостаток strace – замедление работы приложений, в десятки или даже сотни раз, 
поэтому в production среде применяйте аккуратно.

Основные системные вызовы:
* установить сетевое соединение (создать сокет и подключить его к удаленному серверу);
* отправить или получить данные сетевого соединения;
* открыть, прочитать или записать файл (который может располагаться на локальной или удаленной файловой системе любого типа);
* создать новый процесс (фактически, запустить приложение);
* выделить/освободить память (malloc/free) и т.д.

`strace -p <pid>` - отследить уже запущенный процесс

`strace -f <pid>` - отследить так же дочерние процессы

Другие опции:
* `-s [length]` - длина строки (по умолчанию 32)
* `-o [filename]` - записать вывод в файл
* `-y` - выводить пути для файловых дескрипторов
* `-e [syscall]` - отфильтровать только нужные системные вызовы или события (например `strace -e open`)

**eBPF** - еще один инструмент (не использует ptrace), позволяющий отследить, что происходит в ОС, 
ознакомиться с полезным набором утилит [iovisor BCC](https://github.com/iovisor/bcc).

**Процесс зомби** - дочерний процесс родитель которого не смог обработать его код возврата

**Процесс сирота** - процесс родитель которого завершился до выполнения дочернего процесса.

**exit code (код возврата)** - число выдаваемое после завершения функции, при успешном выполнении 0, 
отличие от 0 обычно сообщает об ошибке, и в разных процессах коды могут обозначать разные результаты, 
в баше exit code можно узнать через служебную переменную `$?` 

Состояния процессов:
* `D` - uninterruptible sleep (непрерываемый сон, обычно во время IO операций);
* `R` - running и runnable (исполняется или ожидает исполнения);
* `S` - interruptable sleep (обычный спящий процесс, который может быть прерван, ожидает какого-то события);
* `T` - остановлен сигналом управления задачами;
* `Z` - зомби-процесс.

`uptime` - команда, показывающая load average за последние 1, 5 и 15 минут. 

**Load average (LA)** - среднее число процессов в состояниях R и D за рассчитываемый промежуток времени.

`ps` - process state По умолчанию показывает “собственные” процессы пользователя в том терминале, 
из которого ps запущен. Имеет множество ключей, их можно сочетать:
* `a` - убирает ограничение о собственных процессах
* `u` – добавляет расширенный набор часто нужных колонок
* `x` – убирает ограничение о процессах, запущенных из текущего терминала
* `w/ww` – убирает ограничение по длине вывода.
* `-p` - выбрать pid
* `-u` - выбрать пользователя
* `-o [pid,user,comm,etime,%mem,%cpu]` - вывести дополнительные колонки
* `--sort=-%mem` - добавить сортировку

`Ctrl + Z` - послать процессу сигнал `TSTP` (temporary stop) (20)

`Ctrl + C` - послать процессу сигнал `INT` (interrupt) (2)

`kill -[SIGNAL] <pid>` - послать процессу сигнал (по умолчанию TERM (15)), так же сигналы могут быть переданы 
по имени или по номеру

`SIGKILL` (9) и `SIGSTOP` (23) – два сигнала, которые не могут быть перехвачены процессом и обработаны как-то 
по желанию разработчика (на все остальные сигналы можно повесить подобные обработчики).

**Основное различие fork и clone** – в возможности clone создавать треды. 
С точки зрения планирования процессорного времени для ОС процессы и потоки идентичны,
поэтому может оказаться полезно знать, что какой-то единичный процесс может внутри плодить множество тредов 
и сильно нагружать CPU (один PID, разные thread id)

Удаленный файл возможно восстановить в случае если он используется каким-либо процессом 
забрав его из дескриптора процесса:
```
$ python3 -c "import time;f=open('/tmp/do_not_delete_me',
'r');time.sleep(600);" &
[1] 181248
$ lsof -p 181248 | grep do_not_delete_me
python3 181248 vagrant 3r REG 253,0 14 1572876 /tmp/do_not_delete_me
$ cat /tmp/do_not_delete_me
valuable_data
$ rm /tmp/do_not_delete_me
$ cat /tmp/do_not_delete_me
cat: /tmp/do_not_delete_me: No such file or directory
$ lsof -p 181248 | grep do_not_delete_me
python3 181248 vagrant 3r REG 253,0 14 1572876 /tmp/do_not_delete_me (deleted)
$ cat /proc/181248/fd/3 > /tmp/do_not_delete_me
$ cat /tmp/do_not_delete_me
valuable_data
```
**Будьте осторожны**. Если вы удаляете что-то, не зная об использовании файла процессом,
то, несмотря на кажущееся отсутствие на файловой системе, файл продолжит занимать место на ней. 
Нередко такое происходит с логами при некорректно настроенном внешнем процессе ротации, 
сигнал `USR1` может помочь в этом случае (отпустить удаленные файлы) и пересоздать актуальные.
## 4. Операционные системы (лекция 2)
### 4.1 Оценка потребления ресурсов
`free` - утилита отображающая состояние памяти и свопа. Раздел `free` содержит вообще не занятую память, 
раздел `buff/cache` включают в себя в частности страничный кэш блочных устройств, 
который ускоряет доступ к горячим данным, но может быть в любой момент сброшен командой 
`echo 3 >/proc/sys/vm/drop_caches`

`top` – просмотреть список активных процессов в системе с сортировкой по потребляемому 
процессорному времени (по умолчанию), `Shift + F` - для интерактивного меню, 
где `s` – меняет сортировку и `d` – включает/выключает отображение колонки.

`atop` – программа для записи исторического top с заданным интервалом. Возможно, с учетом современных подходов
к сбору метрик и eBPF уже не столь актуальна, но может быть полезна. `t`/`Shift + t` для перехода по интервалам,
`atop -r <log> -b <time>` для старта с нужного времени.

`htop` – более современный вариант top. Top был написан задолго до эпохи многоядерных систем, 
htop представляет нагрузку с учетом визуализации отдельных ядер.

`mpstat` – аналогичная по сути тестовая утилита с более подробной статистикой.

`iotop` – аналогичная top утилита, только для дисковой подсистемы. Далеко не всегда, 
даже на специализированном сервере (баз данных) очевидно, какой процесс вызывает высокую загрузку дисков,
`iotop` поможет в этом разобраться.

`iftop` - показывает сетевое взаимодействие без привязки к процессам.

`nethogs <interface>` - более подробная сетевая статистика

`sar` - аналогичная утилита для просмотра сетевой активности на интерфейсе
### 4.2 Ядро, модули

`uname -r` - посмотреть версию ядра

`lsb_release -a` или `cat /etc/issue` - посмотреть версию дистрибутива

`grep -v ^# /boot/config-$(uname -r) | tail -n2` - посмотреть, с какой конфигурацией ядро собрано

`dpkg -l | grep linux-image-5` - посмотреть установочный пакет ядра

`lsmod` - посмотреть какие модули ядра загружены в данный момент

`modinfo <module>` - посмотреть информацию о модуле

`modprobe <module>` - установить модуль с зависимостями

`/etc/rsyslog.conf` - конфигурационный файл системных логов

`cat /proc/cmdline` - отобразить параметры загрузки ядра

`BOOT_IMAGE=/boot/vmlinuz-5.4.0-80-generic` - путь до образа, из которого ядро загружено

`root=/dev/mapper/vgvagrant-root` - на каком устройстве находится корневая файловая система

`ro` - монтировать корневую файловую систему в RO режиме во время загрузки

`net.ifnames=0 biosdevname=0` - параметры для подсистемы udev об именовании сетевых интерфейсов

`quiet` - “тихая” загрузка без сообщений

`/etc/default/grub` - файл конфигурации загрузчика системы, после изменений параметры нужно применить командой
`update-grub`

`sysctl` - программа для работы с конфигурацией ядра, при внесении изменений они не сохранятся после перезагрузки,
конфигурации хранятся в файлах в директории `/etc/sysctl.d/` и `/etc/sysctl.conf`

`dmesg` – инструмент доступа к записям ядра. В `dmesg` (ключ `-T` – конвертировать время в человеко-читаемое)
присутствует информация о загрузке ОС, об изменении состояния аппаратных ресурсов. Проблемы с дисками, 
отвалившиеся сетевые карты, ошибки при коррекции ошибок ECC – многие обращающие на себя внимание сообщения
найдут свое место здесь.

`syslog` – штатный логер, куда попадают сообщения уже от приложений в пространстве пользователя.
Мест, куда приложения могут писать логи, – множество: от локальных файлов до сервисов вроде `journald`. 
Однако `/var/log/syslog` остается местом, куда стоит заглянуть при оценке состояния системы.



### 4.3 Системы инициализации: systemd
`init` (PID 1) – собирательное название для контроллера инициализации ОС, а не конкретная технология.

Система инициализации отвечает за:
* достижение корректного состояния на разных этапах загрузки;
* запуска служб самой ОС и прикладных программ в нужном порядке;
* монтирование файловых систем;
* обратный процесс при выключении ОС;
* init должен уметь “усыновлять” процессы, ставшие “сиротами”.

`init` – не единственный процесс, который создан ядром. Процессы в ps в квадратных скобках – “ядерные” процессы, 
что видно по 0 размеру RSS памяти в юзер-спейсе.

Систем инициализации было разработано много, но стандарт для большинства популярных дистрибутивов сегодня – `systemd`.

Базовые команды:
* `systemctl list-units --all` - посмотреть все юниты под управлением systemd
* `systemctl status <service>` - посмотреть статус работы сервиса сразу же виден путь расположения юнит-файла, 
который отвечает за сервис
* `systemctl start|stop|restart|reload <service>` - запустить, остановить, перезапустить, перезагрузить конфигурацию
сервиса
* `systemctl enable|disable <service>` - автозапуск сервиса включен/выключен
* `systemctl cat <service>` - отобразить юнит-файл сервиса
* `systemctl edit --full <service>` - отредактировать юнит-файл сервиса
* `systemctl daemon-reload` - перечитать измененные юнит-файлы самого systemd
* `systemctl list-dependencies <service>` - посмотреть зависимости сервиса
* `journalctl -b -u <service>` - посмотреть логи сервиса nginx, которые были записаны с момента загрузки, b от boot

`lsns` - отобразить пространства имен

**Пространство имён** — это функция ядра Linux, позволяющая изолировать и виртуализировать 
глобальные системные ресурсы множества процессов. Примеры ресурсов, которые можно виртуализировать: ID процессов,
имена хостов, ID пользователей, доступ к сетям, межпроцессное взаимодействие и файловые системы. 
Одной из общих целей пространств имён является поддержка реализации контейнеров — инструмента для виртуализации 
на уровне операционной системы (а также других целей), обеспечивающего группу процессов иллюзией того, 
что они являются единственными процессами в системе. Поэтому одной из главных целей пространства имён является 
поддержка контейнеризации в Linux.

`unshare -f --pid --mount-proc /bin/bash` - создать пространство имен и запустить в нем bash

`nsenter --target <PID> --pid --mount` - войти в созданное пространство имен

#### Дополнительные материалы:
Сайт и книги [Brendan Gregg](http://www.brendangregg.com/overview.html), в частности:
* [USE-метод](http://www.brendangregg.com/usemethod.html)
* [Широкий список утилит для мониторинга](http://www.brendangregg.com/linuxperf.html)

Пример быстрого интерактивного анализа хоста на практике:
* [Netflix](https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55)