# Основы системного администрирования.
## 1. Работа в терминале (лекция 1).
__FHC__ (filesystem hierarchy standard) - иерархический стандарт директорий Linux

`whoami` - отобразить имя пользователя

`pwd` - отобразить текущую директорию

`alias` - вывести список алиасов

`alias new_alias="comand"` - задать алиас

`~/.bashrc` - файл в который можно задать постоянные алиасы

`which <command>` - вывести расположение исполняемого файла команды

`type <command>` - отобразить исполняемый файл команды

`read [var]` - прочитать введенные данные в переменную _var_

`echo $var` - вывести значение переменной

### Vagrant
**Vagrant** - система оркестрации виртуальных машин (в нашем случае для оркестрации oracle Virtual BOX)

`vagrant init` - инициализация виртуальной машины в выбранной директории

`vagrant up` - запустить виртуальную машину

`vagrant suspend` - приостановить виртуальную машину

`vagrant halt` - выключить виртуальную машину

`vagrant ssh` - подключиться по ssh к виртуальной машине

## 2. Работа в терминале (лекция 2)

**Потоки данных:**
* **stdin** - стандартный ввод, условный номер (дескриптор) 0 (например ввод команды в shell)
* **stdout** - стандартный вывод, условный номер (дескриптор) 1 (например вывод результата команды на экран)
* **stderr** - стандартный вывод ошибок, условный номер (дескриптор) 2 (например вывод ошибки на экран при неправильных 
аргументах команды)

**Процесс** - экземпляр запущенной программы

`lsof` - список открытых файлов (в колонке FD отмечены дескрипторы файлов)

**_Открытие любых файлов приводит к выделению им файловых дескрипторов, все они получают номера_**

`/dev` - псевдо-файловая система представления устройств

`/proc` - псевдо-файловая система представления структур ядра (информация в директории актуальна только на момент
просмотра и постоянно изменяется)

**_С псевдо-файловыми системами доступна работа только в режиме Read-only_**

`evtest /dev/input/event2` - тестирования потока ввода с устройства

**PID, Process Identifier** - числовой идентификатор процесса, однозначно его определяющий. Находясь в shell, 
мы можем узнать собственный PID через зарезервированную переменную `$`: `echo $$`.

`jobs -l` - вывести фоновые задачи (отправленные в фон через ctrl+z), параметр `-l` указывает pid

**_PPID, Parent PID - атрибут процесса, определяющий идентификатор его родительского процесса. 
Все процессы в Linux выстроены в дерево и должны иметь “родителя”. Так, для sleep 1h родителем будет bash, 
из которого sleep вызвали. Для PPID в shell так же есть одноименная переменная: `echo $PPID`_**

`pstree -p [pid]` - отобразить дерево процессов, `-p` отображает PID

Часть информации в `/proc` представлена с группировкой по PID: в `/proc/<PID>` 
находятся относящиеся к конкретному процессу данные.

`lsof -p [pid]` - вывести список открытых файлов связанных с _pid_

`[1,2]>` (по умолчанию `1>`) - перенаправить поток (при перенаправлении в поток добавить `&` например `2>&1`)

`<` - перенаправить поток ввода (например: `read NEW_WAR < text`)

`|` - pipe, перенаправить stdout одного в stdin другого 

`||` - логическое или

`&&` - выполнить команду после успешного завершения предыдущей

`;` - выполнить команду после предыдущей

`<comand> $(<function> [arg])` - передать команде на выполнение результат функции

## 3. Операционные системы (лекция 1)
**POSIX** - (Portable  Operating System Interface for UniX) Совместимая UNIX-подобная ОС Linux

**Системные вызовы** – метод общения приложений и ОС. Напрямую системные вызовы используются редко,
а формат обращения к ним сложен для прикладного программирования. Над системными вызовами написаны библиотеки,
которые удобнее для прямого вызова программистами.

`ldd` — скрипт в UNIX/Linux, помогающий определить список разделяемых библиотек (shared libraries),
от которых зависит программа.

`strace <command>` – программа, использующая подсистему ядра ptrace для отслеживания системных вызовов.
Основной недостаток strace – замедление работы приложений, в десятки или даже сотни раз, 
поэтому в production среде применяйте аккуратно.

Основные системные вызовы:
* установить сетевое соединение (создать сокет и подключить его к удаленному серверу);
* отправить или получить данные сетевого соединения;
* открыть, прочитать или записать файл (который может располагаться на локальной или удаленной файловой системе любого типа);
* создать новый процесс (фактически, запустить приложение);
* выделить/освободить память (malloc/free) и т.д.

`strace -p <pid>` - отследить уже запущенный процесс

`strace -f <pid>` - отследить так же дочерние процессы

Другие опции:
* `-s [length]` - длина строки (по умолчанию 32)
* `-o [filename]` - записать вывод в файл
* `-y` - выводить пути для файловых дескрипторов
* `-e [syscall]` - отфильтровать только нужные системные вызовы или события (например `strace -e open`)

**eBPF** - еще один инструмент (не использует ptrace), позволяющий отследить, что происходит в ОС, 
ознакомиться с полезным набором утилит [iovisor BCC](https://github.com/iovisor/bcc).

**Процесс зомби** - дочерний процесс родитель которого не смог обработать его код возврата

**Процесс сирота** - процесс родитель которого завершился до выполнения дочернего процесса.

**exit code (код возврата)** - число выдаваемое после завершения функции, при успешном выполнении 0, 
отличие от 0 обычно сообщает об ошибке, и в разных процессах коды могут обозначать разные результаты, 
в баше exit code можно узнать через служебную переменную `$?` 

Состояния процессов:
* `D` - uninterruptible sleep (непрерываемый сон, обычно во время IO операций);
* `R` - running и runnable (исполняется или ожидает исполнения);
* `S` - interruptable sleep (обычный спящий процесс, который может быть прерван, ожидает какого-то события);
* `T` - остановлен сигналом управления задачами;
* `Z` - зомби-процесс.

`uptime` - команда, показывающая load average за последние 1, 5 и 15 минут. 

**Load average (LA)** - среднее число процессов в состояниях R и D за рассчитываемый промежуток времени.

`ps` - process state По умолчанию показывает “собственные” процессы пользователя в том терминале, 
из которого ps запущен. Имеет множество ключей, их можно сочетать:
* `a` - убирает ограничение о собственных процессах
* `u` – добавляет расширенный набор часто нужных колонок
* `x` – убирает ограничение о процессах, запущенных из текущего терминала
* `w/ww` – убирает ограничение по длине вывода.
* `-p` - выбрать pid
* `-u` - выбрать пользователя
* `-o [pid,user,comm,etime,%mem,%cpu]` - вывести дополнительные колонки
* `--sort=-%mem` - добавить сортировку

`Ctrl + Z` - послать процессу сигнал TSTP (temporary stop) (20)

`Ctrl + C` - послать процессу сигнал INT (interrupt) (2)

`kill -[SIGNAL] <pid>` - послать процессу сигнал (по умолчанию TERM (15)), так же сигналы могут быть переданы 
по имени или по номеру

`SIGKILL` (9) и `SIGSTOP` (23) – два сигнала, которые не могут быть перехвачены процессом и обработаны как-то 
по желанию разработчика (на все остальные сигналы можно повесить подобные обработчики).

**Основное различие fork и clone** – в возможности clone создавать треды. 
С точки зрения планирования процессорного времени для ОС процессы и потоки идентичны,
поэтому может оказаться полезно знать, что какой-то единичный процесс может внутри плодить множество тредов 
и сильно нагружать CPU (один PID, разные thread id)

Удаленный файл возможно восстановить в случае если он используется каким-либо процессом 
забрав его из дескриптора процесса:
```
$ python3 -c "import time;f=open('/tmp/do_not_delete_me',
'r');time.sleep(600);" &
[1] 181248
$ lsof -p 181248 | grep do_not_delete_me
python3 181248 vagrant 3r REG 253,0 14 1572876 /tmp/do_not_delete_me
$ cat /tmp/do_not_delete_me
valuable_data
$ rm /tmp/do_not_delete_me
$ cat /tmp/do_not_delete_me
cat: /tmp/do_not_delete_me: No such file or directory
$ lsof -p 181248 | grep do_not_delete_me
python3 181248 vagrant 3r REG 253,0 14 1572876 /tmp/do_not_delete_me (deleted)
$ cat /proc/181248/fd/3 > /tmp/do_not_delete_me
$ cat /tmp/do_not_delete_me
valuable_data
```
**Будьте осторожны**. Если вы удаляете что-то, не зная об использовании файла процессом,
то, несмотря на кажущееся отсутствие на файловой системе, файл продолжит занимать место на ней. 
Нередко такое происходит с логами при некорректно настроенном внешнем процессе ротации, 
сигнал `USR1` может помочь в этом случае (отпустить удаленные файлы) и пересоздать актуальные.

